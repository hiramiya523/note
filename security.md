# Overview

## web

### Session

- セッションIDに求められる要件
  - 推測不可
        -> 通常の乱数でなく、暗号論的疑似乱数生成器を用いること
  - IDを強制されないこと
  - 漏洩しないこと
    - URLパラメータに付与しない
      Refererや、

### フロント

#### Cookie

cookieにデータを保存することはsessionと比較した場合、
ほとんどのケースで推奨されないが

特に保存してはいけない情報は、
アプリケーション利用者に、改竄されると困る情報
    ユーザーID, 権限情報など

- http onlyは安心できない理由。
  jsから参照、更新ができない。
  XSSの緩和策
  → 完全な防御にならない。
  -> document.documentElement.innerHTMLを取得できるので、マイページ情報の個人情報を取得可能
    (mypageにXSS脆弱性がなくとも、別ページにあればmypageをフェッチできる(Cookieは自動付与.操作出来ないだけで利用可能。同一オリジン)
  -> cserfトークンも取得できてしまう(hiddenに埋め込まれる形式でも、html取得できるので。)

脆弱性について、以下が上げれられる。

- HTTPヘッダ・インジェクション
- クッキーセキュア属性不備
    https通信でもsecure属性がないcookieは平文送信される可能性があり、盗聴されうる。
    方法、
    httpsに紐づくcookieは、http://xxxxxx:443で、レスポンスは失敗しても、リクエスト自体は送信される。
    ⇒ 平文のcookieが、ネットワーク上に流れる。
    ⇒ secure属性は必ずつけましょう。(常時TLS化)
    ⇒ もしだめなら、トークンを発行してそいつにsecure属性を付ける。

cookieのpath属性の制限は、
パスによりセッションを分けたりはできるが、セキュリティ対策には貢献しないことを知っておけ。
⇒ jsは、オリジンポリシーがホスト名単い。

__HOST- : 特別なcookie。同一ホスト名のみにしか送られない。

#### hidden vs Cookie

- hidden
  - メリット  
    hiddenパラメータが、情報漏洩と第三者からの書き換えに対して、堅牢である理由。
  - デメリット  
    本人による書き換えが改ざんが可能

### アプリケーション

### 攻撃手法

#### CSRF

Forgery : 偽造

対策

Token検証

- アップデート案
  - SameSite属性 (Strict, Lax, None)  
      → ブラウザ間で動作に差異が。
      → 古いブラウザは非対応、Getでは送られてしまう。
  - Originヘッダを付与
      サーバ側でOriginヘッダを照合すればよいのでは？
      → honoや、sveltekitでも採用されつつある？
  - Sec-Fetch-XXX を利用
      リクエスト元の詳細な情報がわかる。
      割と最近なので、古いブラウザは非対応の可能性.

結論。Originヘッダをチェック。Sec-Fetch-をチェック

#### DOM Based XSS

Javasctipによる処理の不備が原因となる、XSS脆弱性。
近年JSの実装が増えているため、相対的に増加。

色々な方法がある。一例として,

- innerHTMLに、<img src=/ onerror=alert(1) >が挿入出来たら終わり。
- document.writeに、<img src=/ onerror=alert(1) >が挿入出来たら終わり。
- location.hrefに、scriptを挿入されたら終わり。

などなど。

- 対策変
  - URLのスキームは、http/httpsに限定
      location.href, src属性, href属性など
  - 最新のライブラリを使う(JQueryなど古い物特有の脆弱性がある)
  - textContentが使えないなら、せめてエスケープしよう

    ```js
    // ユーザ入力を元にDOM生成するなら、エスケープ必須。
    const query = payload.get('query');
    function escapeHTML(unsafe) {
    return unsafe
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
      }
      document.getElementById('output').innerHTML = escapeHTML(query);
    ```

#### セッションID固定化攻撃

Session Fixation
https://www.ubsecure.jp/blog/session_fixation

Webサーバーの中には、ブラウザ側で発行したセッションIDを使用可能とする機能を有効化しているものもあります。

セッションID固定化攻撃では、この機能を悪用するのです。まずは攻撃者が生成したセッションIDを含んだURLなどを正規ユーザーに送りつけます。正規ユーザーがそのURLからログインすると、同じセッションIDを使って攻撃者も正規ユーザーと同じようにサイト内を徘徊することが可能となるのです。

#### 内容

#### 対策

1. ログイン前後で、Session Regenerate
1. FWの都合で上記対策が打てないとき、SESSION IDとは別のランダムな値を生成し、Session変数に格納。
    それをSetCookieして、リクエスト毎にチェック。
    ipaにもある=>https://www.ipa.go.jp/security/vuln/websecurity/session-managemenにもある=>

https://www.ipa.go.jp/security/vuln/websecurity/index.html

#### ログイン

##### 実装

- エラーメッセージ
  ID or パスワード、どちらが間違っているかバレるのはマズイ案件。

- アカウントロック
  → アカウントロックの解除を、メールアドレスでURLを送信、時間経過でも、
  (個人的に、管理画面から解除できるのもよいかも)

##### 攻撃

パスワードリスト攻撃
パスワードスプレー攻撃 (「low-and-slow」攻撃)
リバースブルートフォース攻撃
辞書攻撃
ジョーアカウント探索

対策の対策→

##### 対策

- 文字数は8桁以上は必須。6桁以下は秒。
    英数字64文字で考えたとき、
    6桁 → 約570億
    8桁 → 約220兆

    ただ、、、
    https://pc.watch.impress.co.jp/docs/news/1492292.html
    アルファベットの大文字/小文字/数字/記号の組み合わせでも8桁程度なら7時間で解析できることが示された。
　これを踏まえて同社では、安全性の高いパスワードの要件として
  「15文字以上であること」、
  「アルファベットの大文字と小文字/数字/記号を含めること」、
  「3～6カ月ごとにパスワードを変更すること」を挙げたほか、
  「パスワードを使い回さない」運用を勧めている。

https://www.keepersecurity.com/blog/ja/2023/07/03/how-long-would-it-take-a-cybercriminal-to-crack-my-password/
  逆に、6文字以下のパスワードは、大文字、数字、記号を組み込んでも即座に解読されてしまいます。

- アカウントロック
    ブルートフォースアタック対策

- ソルトを生成して、パスワードをハッシュ化。
ソルトをDBに。
辞書攻撃への効果
一意性の付与:
ソルトを加えることにより、同じパスワードでも異なるユーザ間で異なるハッシュが生成されます。辞書攻撃では、予め用意したハッシュテーブルを利用してパスワードを解読しようとしますが、ソルトを使うことで同じパスワードが異なるハッシュ値になるため、攻撃の効果を減少させます。
大規模なハッシュプリコンピュテーションの防止:
攻撃者が一度ハッシュ結果を生成してしまう（レインボーテーブルのように）方法では、ソルトによってパスワードを推測するために個別のハッシュ出力が必要になります。ソルトがあると、プリコンピュテーションしたハッシュが使えず、逆算する手間が大幅に増えます。
攻撃計算量の増加:
ソルトを使うことで、攻撃者はユーザごと、パスワード入力ごとに異なるソルトを適用するため、計算のコストが増加し、攻撃全体の効率を著しく低下させます。
まとめ
ソルトを利用することは、パスワードハッシュの一部であるだけでなく、辞書攻撃やその他のハッシュベースの攻撃を困難にするための重要なセキュリティ対策の一部です。これにより、たとえ攻撃者がデータベースにアクセスできても、ハッシュ化されたパスワードを元のプレーンテキストパスワードに変換するための労力が増大することから、セキュリティ性が高まります。

- パスワード失敗率の監視
  ログイン失敗率が急激に上昇する。(失敗回数/時間)
  → ログでIP割り出して、IP毎遮断するのもありか。

### TEMP
https://zenn.dev/dyoshikawa/scraps/7143f57e871c57

TCP通信の場合、TCPセッションの確立が必須となるため、IPスプーフィングの成立は困難
そこで攻撃者はさらにTCPシーケンス番号予測攻撃でTCPセッション確立を偽装しようとする
そのためシステム側ではTCPシーケンス番号予測攻撃への対策をする

TCPシーケンス番号
TCPパケットの順序や欠落がないかを確認するための番号
シーケンス番号の初期値をイニシャルシーケンス番号（ISN）という

TCPシーケンス番号予測攻撃
IPスプーフィングした攻撃者クライアントが任意のクライアント側ISNを生成しSYNをサーバに送信
サーバはサーバ側ISNを生成しSYN+ACKを（攻撃者ではない）真正なIPに応答する
攻撃者はSYN+ACKを受け取れないが気にせず、サーバ側ISNを予測してその値でACKを送信する
ACKを受け取ったサーバはシーケンス番号を確認し、正しい番号であればセッションを確立させてしまう

要するに、TCPセッションの確立にはクライアント側ISNとサーバ側ISNを適切に交換することが必要
なので攻撃者はサーバ側ISNの値を読み切れれば攻撃が成功する

TCPシーケンス番号予測攻撃への対策
ISNを予測不可能になるようランダム化する（昔は予測が容易な設定がされていたことがしばしばあったらしい）