# Features

## Data Types

## Functions
- 戻り値に、セミコロンは不要
  ```
  -> i32
  x + 1;
  ```
  これだと、文になるのでコンパイルエラーとなる。(空のタプルになるらしい)

- 関数内に関数定義可能
  

## Macro
関数と見分けがつきやすくするため、!が付く。


# ルートファイル
Rustにはルートファイルという考え方があります。以下のどちらかがrootになります。

src/main.rs
src/lib.rs
Cargo.tomlで明示的に設定して変更することも可能ですが、ほとんどの場合上記のデフォルトが使用されることでしょう。

Rustでは自分が定義したモジュールはルートファイルからmodキーワードを使って宣言が必要です。
さもないとそのファイルは無いも同然として扱われ、コンパイルすらされません。

## 配列、スライス、ベクタ

### 違い
配列とベクタは，別のものです．しかし，これらは次の点で共通しています．

1. 同じ型の値が連続して並んでいる．
1. 要素の個数を知ることができる．
1. 後に [i] を付けると i 番目の要素にアクセスできる．
1. for 式で走査できる．
⇒ `このような共通点をもつ 2 つを，まとめて扱うための型があります．スライスです．`

### 配列
有効なケース
- ヒープよりもスタックにデータのメモリを確保したい時
- 常に固定長の要素があることを確認したい時に有効です。 
ベクタ型ほど柔軟ではありません。

### スライス
所有権のない別のデータ型は、スライスです。スライスにより、コレクション全体ではなく、 その内の一連の要素を参照することができます。

- スライスは配列、ベクタ、文字列などの一部分を参照ためのものです。基本的に参照なので所有権の移動は発生しません。

- つまりsliceってのは、 配列とかVectorへの参照ということですかね。
sliceの型は &[T] なので、参照なのはわかる

&str型は、ある文字列のスライス「&[u8]」です。参照型で、`所有権を持たない型`です。

- 内部的には、スライスデータ構造は、開始地点とスライスの長さを保持


- 

### ベクタ
ベクタはヒープ領域の確保される可変配列です。

標準ライブラリによって提供されている配列と似たようなコレクション型で、 サイズを伸縮させることができます。
配列とベクタ型、どちらを使うべきか確信が持てない時は、 おそらくベクタ型を使うべきです。

ベクタ型よりも配列を使いたくなるかもしれない例は、1年の月の名前を扱うプログラムです。
そのようなプログラムで、 月を追加したり削除したりすることまずないので、配列を使用できます。常に12個要素があることもわかってますからね.


# メモリ

String型の管理方法

ptr: 64bit整数 ポインタ,
len: 64bit整数 文字列長,
capacity: 64bit整数 ヒープ確保領域

-  s2 = s1　で、コピーではなくmoveになる理由
 ダブルフリーになる.
 deep copy したいなら、cloneメソッドを呼ぶ。 s1.clone()

- shallow copyのようだが、moveとの違いは元の変数が使えるかどうか

- プリミティブ型だとmoveにならない理由
これはコンパイルエラーにならない
```
let x = 5;
let y = x;
println!("x = {}, y = {}", x, y);
```
コンパイル時点で既知のデータサイズなので　


## スタック
- last in, first out
  最後に入れたものが最初に出てくる

- データを追加することは、スタックにpushするといい、
  データを取り除くことは、スタックからpopすると表現し

- スタックは高速です: 新しいデータを置いたり、データを取得する場所を探す必要が絶対にないわけです。

- スタック上のデータは全て既知の固定サイズでなければならないということです。
  
- プリミティブ型は、スタックに保存される

- データを破棄するタイミングが明確になる？
  ⇒ これがGCを不要とする理由か？

## ヒープ
スタックのデータへのアクセスよりも低速
  
## 処理の流れ
コードが関数を呼び出すと、関数に渡された値(ヒープのデータへのポインタも含まれる可能性あり)と、 関数のローカル変数がスタックに載ります。関数の実行が終了すると、それらの値はスタックから取り除かれます。

-  ひとたび、メモリを所有している変数がスコープを抜けたら、 メモリは自動的に返還されます
 (Rustは、閉じ波括弧で自動的にdrop関数を呼び出します。: https://doc.rust-jp.rs/book-ja/ch04-01-what-is-ownership.html)

# 用語
- 文, statements
 なんらかの動作をして値を返さない命令です

- 式、expressions
何かに評価される

- パニック
 プログラムがエラーで終了したことを表すRust用語です。

# Control Flow
- if, else の確ブロックの返すデータ型は一致しないとコンパイルエラー？

# 所有権(所有責任)
- marocして、freeするまでの責任ととらえることもできる
  
- 如何なる場合でも、所有者は一人


- 関数に値を渡す時もmoveする
```
let s = String::from("hello");  // sがスコープに入る
takes_ownership(s);             // sの値が関数にムーブされ...
                                // ... ここではもう有効ではない
```

- 戻り値もmoveする


## 借用
- 借用はスライス
  スライスにより、コレクション全体ではなく、 その内の一連の要素を参照する

- 特定のスコープで（同一スコープ？）、同一参照元から、`可変を含む`複数の借用を作ることは出来ない
  ⇒　一つしか可変な参照を持てない
  ```
    // cannot borrow `s` as mutable more than once at a time
    let mut s = String::from("hello");
    let r1 = &s; // 問題なし
    let r2 = &s; // 問題なし
    let r3 = &mut s; // 大問題！
  ```
  
  スコープを分ければ問題はなくなる
  ```
  let mut s = String::from("hello");
  {
      let r1 = &mut s;

  } // r1はここでスコープを抜けるので、問題なく新しい参照を作ることができる
  let r2 = &mut s;
  ```

# ライフタイム
- プリミティブ型と、それ以外で挙動が異なる
- スタック領域に依存

- `ダングリングポインタ`
  保持しているポインタが、別の箇所で開放されたものがそう。
  宙に浮いたイメージ。

  ダングリングポインタを防ぐ仕組みが`ライフタイム。`

# クレート
と言われたら。バイナリ か、ライブラリのいずれか。

- Create Root
  コンパイルの開始点で、クレートのルートモジュールを作るsrcFile

## パッケージ
１つ以上のCreateを持つ、機能軍を提供。

- 0個 or 1個のライブラリクレートが必要。それ以上はダメ。
　バイナリクレートは、無制限。

- パッケージ作成
cargo new my-project


Cargoは src/main.rs が、パッケージと同じ名前を持つバイナリクレートのクレートルートであるという慣習に従っている

パッケージディレクトリに src/lib.rs が含まれていたら、パッケージにはパッケージと同じ名前のライブラリクレートが含まれており、src/lib.rs がそのクレートルートなのだと判断します。


## ゼロコスト抽象化

forループによる検索より、イテレータを使う方がベンチマークが良い。
イテレータは、Rustのゼロコスト抽象化の一つであり、これは、抽象化を使うことが追加の実行時オーバーヘッドを生まないことを意味しています

